import*as e from"tedious";import{Connection as r,Request as t}from"tedious";import{isDefined as n,isArray as s,isObject as a,isString as o,isFunction as i,isNotDefined as u,isEmptyArray as l,isEmptyObject as c,isNotString as d,isEmptyString as p,isBlankString as h,isNotArray as m,isNotObject as f,isNull as _,isUndefined as E,isNotArrayOfString as g}from"itee-validators";import b from"path";import{kStringMaxLength as y}from"buffer";import v from"fs";import{Writable as N}from"stream";console.log("Itee.Database v8.0.0 - EsModule");
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class TDatabaseController
 * @classdesc The TDatabaseController is the base class to perform CRUD operations on the database
 */
class T{static __checkData(e,r,t){const s=r.body,a=r.params,o=r.query;return n(s)&&s[e]?s[e]:n(a)&&a[e]?a[e]:n(o)&&o[e]?o[e]:void T.returnError({title:"Erreur de paramètre",message:`${e} n'existe pas dans les paramètres !`},t)}static _formatError(e){let r=[];if(s(e))for(let t=0,n=e.length;t<n;++t)r=r.concat(T._formatError(e[t]));else if(a(e))if("ValidationError"===e.name){let t="",n=e.errors;for(let e in n)Object.prototype.hasOwnProperty.call(n,e)&&(t+=n[e].message+"<br>");r.push({title:"Erreur de validation",message:t||"Aucun message d'erreur... Gloups !"})}else"VersionError"===e.name?r.push({title:"Erreur de base de donnée",message:"Aucun document correspondant n'as put être trouvé pour la requete !"}):r.push({title:e.title||"Erreur",message:e.message||"Aucun message d'erreur... Gloups !"});else{if(!o(e))throw new Error(`Unknown error type: ${e} !`);r.push({title:"Erreur",message:e})}return r}static returnNotFound(e){if(i(e))return e();e.headersSent||e.status(204).end()}static returnError(e,r){if(i(r))return r(e,null);if(r.headersSent)return;const t=T._formatError(e);r.format({"application/json":()=>{r.status(500).json(t)},default:()=>{r.status(406).send("Not Acceptable")}})}static returnData(e,r){if(i(r))return r(null,e);if(r.headersSent)return;const t=s(e)?e:[e];r.format({"application/json":()=>{r.status(200).json(t)},default:()=>{r.status(406).send("Not Acceptable")}})}static returnErrorAndData(e,r,t){if(i(t))return t(e,r);if(t.headersSent)return;const n={errors:e,datas:r};t.format({"application/json":()=>{t.status(416).json(n)},default:()=>{t.status(416).send("Range Not Satisfiable")}})}constructor(e={}){const r={driver:null,useNext:!1,...e};this._driver=r.driver,this._useNext=r.useNext}return(e,r={}){const t=Object.assign({immediate:null,beforeAll:null,beforeReturnErrorAndData:null,afterReturnErrorAndData:null,beforeReturnError:null,afterReturnError:null,beforeReturnData:null,afterReturnData:null,beforeReturnNotFound:null,afterReturnNotFound:null,afterAll:null},r,{returnErrorAndData:T.returnErrorAndData.bind(this),returnError:T.returnError.bind(this),returnData:T.returnData.bind(this),returnNotFound:T.returnNotFound.bind(this)});return t.immediate&&t.immediate(),function(r=null,s=null){const a=n(s),o=n(r);t.beforeAll&&t.beforeAll(),a&&o?(t.beforeReturnErrorAndData&&t.beforeReturnErrorAndData(r,s),t.returnErrorAndData(r,s,e),t.afterReturnErrorAndData&&t.afterReturnErrorAndData(r,s)):a&&!o?(t.beforeReturnData&&t.beforeReturnData(s),t.returnData(s,e),t.afterReturnData&&t.afterReturnData(s)):!a&&o?(t.beforeReturnError&&t.beforeReturnError(r),t.returnError(r,e),t.afterReturnError&&t.afterReturnError(r)):a||o||(t.beforeReturnNotFound&&t.beforeReturnNotFound(),t.returnNotFound(e),t.afterReturnNotFound&&t.afterReturnNotFound()),t.afterAll&&t.afterAll()}}create(e,r,t){const n=e.body;u(n)?T.returnError({title:"Erreur de paramètre",message:"Le corps de la requete ne peut pas être null ou indefini."},this._useNext?t:r):s(n)?l(n)?T.returnError({title:"Erreur de paramètre",message:"Le tableau d'objet de la requete ne peut pas être vide."},this._useNext?t:r):this._createMany(n,r,t):a(n)?c(n)?T.returnError({title:"Erreur de paramètre",message:"L'objet de la requete ne peut pas être vide."},this._useNext?t:r):this._createOne(n,r,t):T.returnError({title:"Erreur de paramètre",message:"Le type de donnée de la requete est invalide. Les paramètres valides sont objet ou un tableau d'objet."},this._useNext?t:r)}_createOne(){}_createMany(){}read(e,r,t){const s=e.params.id,a=e.body,o=n(a),i=o?a.ids:null,u=o?a.query:null,_=o?a.projection:null;n(s)?d(s)?T.returnError({title:"Erreur de paramètre",message:"L'identifiant devrait être une chaine de caractères."},this._useNext?t:r):p(s)||h(s)?T.returnError({title:"Erreur de paramètre",message:"L'identifiant ne peut pas être une chaine de caractères vide."},this._useNext?t:r):this._readOne(s,_,r,t):n(i)?m(i)?T.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants devrait être un tableau de chaine de caractères."},this._useNext?t:r):l(i)?T.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants ne peut pas être vide."},this._useNext?t:r):this._readMany(i,_,r,t):n(u)?f(u)?T.returnError({title:"Erreur de paramètre",message:"La requete devrait être un objet javascript."},this._useNext?t:r):c(u)?this._readAll(_,r,t):this._readWhere(u,_,r,t):T.returnError({title:"Erreur de paramètre",message:"La requete ne peut pas être null."},this._useNext?t:r)}_readOne(){}_readMany(){}_readWhere(){}_readAll(){}update(e,r,t){const s=e.params.id,a=e.body,o=n(a),i=o?a.ids:null,_=o?a.query:null,E=o?a.update:null;u(E)?T.returnError({title:"Erreur de paramètre",message:"La mise à jour a appliquer ne peut pas être null ou indefini."},this._useNext?t:r):n(s)?d(s)?T.returnError({title:"Erreur de paramètre",message:"L'identifiant devrait être une chaine de caractères."},this._useNext?t:r):p(s)||h(s)?T.returnError({title:"Erreur de paramètre",message:"L'identifiant ne peut pas être une chaine de caractères vide."},this._useNext?t:r):this._updateOne(s,E,r,t):n(i)?m(i)?T.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants devrait être un tableau de chaine de caractères."},this._useNext?t:r):l(i)?T.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants ne peut pas être vide."},this._useNext?t:r):this._updateMany(i,E,r,t):n(_)?f(_)?T.returnError({title:"Erreur de paramètre",message:"La requete devrait être un objet javascript."},this._useNext?t:r):c(_)?this._updateAll(E,r,t):this._updateWhere(_,E,r,t):T.returnError({title:"Erreur de paramètre",message:"La requete ne peut pas être vide."},this._useNext?t:r)}_updateOne(){}_updateMany(){}_updateWhere(){}_updateAll(){}delete(e,r,t){const s=e.params.id,a=e.body,o=n(a),i=o?a.ids:null,u=o?a.query:null;n(s)?d(s)?T.returnError({title:"Erreur de paramètre",message:"L'identifiant devrait être une chaine de caractères."},this._useNext?t:r):p(s)||h(s)?T.returnError({title:"Erreur de paramètre",message:"L'identifiant ne peut pas être une chaine de caractères vide."},this._useNext?t:r):this._deleteOne(s,r,t):n(i)?m(i)?T.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants devrait être un tableau de chaine de caractères."},this._useNext?t:r):l(i)?T.returnError({title:"Erreur de paramètre",message:"Le tableau d'identifiants ne peut pas être vide."},this._useNext?t:r):this._deleteMany(i,r,t):n(u)?f(u)?T.returnError({title:"Erreur de paramètre",message:"La requete devrait être un objet javascript."},this._useNext?t:r):c(u)?this._deleteAll(r,t):this._deleteWhere(u,r,t):T.returnError({title:"Erreur de paramètre",message:"La requete ne peut pas être vide."},this._useNext?t:r)}_deleteOne(){}_deleteMany(){}_deleteWhere(){}_deleteAll(){}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class w extends N{constructor(e){super(e);const r=e.bufferSize||y;this.memoryBuffer=Buffer.alloc(r),this.offset=0}_final(e){e()}_write(e,r,t){const n=Buffer.isBuffer(e)?e:new Buffer(e,r);for(let e=0,r=n.length;e<r;e++)this.memoryBuffer[this.offset]=n[e],this.offset++;t()}_writev(e,r){for(let r=0,t=e.length;r<t;r++)this.memoryBuffer=Buffer.concat([this.memoryBuffer,e[r]]);r()}_releaseMemory(){this.memoryBuffer=null}toArrayBuffer(){const e=this.memoryBuffer,r=new ArrayBuffer(e.length),t=new Uint8Array(r);for(let r=0;r<e.length;++r)t[r]=e[r];return this._releaseMemory(),r}toJSON(){return JSON.parse(this.toString())}toString(){const e=this.memoryBuffer.toString();return this._releaseMemory(),e}}class R{constructor(e={}){const r={dumpType:R.DumpType.ArrayBuffer,...e};this.dumpType=r.dumpType,this._isProcessing=!1,this._queue=[]}get dumpType(){return this._dumpType}set dumpType(e){if(_(e))throw new TypeError("Dump type cannot be null ! Expect a non empty string.");if(E(e))throw new TypeError("Dump type cannot be undefined ! Expect a non empty string.");this._dumpType=e}setDumpType(e){return this.dumpType=e,this}convert(e,r,t,n,s){e?(this._queue.push({file:e,parameters:r,onSuccess:t,onProgress:n,onError:s}),this._processQueue()):s("File cannot be null or empty, aborting file convertion !!!")}_processQueue(){if(0===this._queue.length||this._isProcessing)return;this._isProcessing=!0;const e=this,r=this._queue.shift(),t=r.file,n=r.parameters,s=r.onSuccess,a=r.onProgress,i=r.onError;if(o(t))e._dumpFileInMemoryAs(e._dumpType,t,n,u,c,d);else{const r=t.data;switch(e._dumpType){case R.DumpType.ArrayBuffer:{const e=r.length,t=new ArrayBuffer(e),n=new Uint8Array(t);for(let t=0;t<e;++t)n[t]=r[t];u(t)}break;case R.DumpType.JSON:u(JSON.parse(r.toString()));break;case R.DumpType.String:u(r.toString());break;default:throw new RangeError(`Invalid switch parameter: ${e._dumpType}`)}}function u(r){e._convert(r,n,l,c,d)}function l(r){s(r),e._isProcessing=!1,e._processQueue()}function c(e){a(e)}function d(r){i(r),e._isProcessing=!1,e._processQueue()}}_dumpFileInMemoryAs(e,r,t,n,s,a){let o=!1;const i=v.createReadStream(r);i.on("error",e=>{console.error(`Read stream on error: ${e}`),o=!0,a(e)});const u=parseInt(t.fileSize),l=new w({bufferSize:u});l.on("error",e=>{o=!0,a(e)}),l.on("finish",()=>{if(!o){switch(e){case R.DumpType.ArrayBuffer:n(l.toArrayBuffer());break;case R.DumpType.String:n(l.toString());break;case R.DumpType.JSON:n(l.toJSON());break;default:throw new RangeError(`Invalid switch parameter: ${e}`)}i.unpipe(),i.close(),l.end()}}),i.pipe(l)}_convert(){}}R.MAX_FILE_SIZE=67108864,R.DumpType=Object.freeze({ArrayBuffer:0,String:1,JSON:2});
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */
class ${static _registerRoutesTo(e,r,t,n,s){for(let a=0,o=s.length;a<o;a++){const o=s[a],i=new(n.get(o.controller.name))({driver:e,...o.controller.options}),u=t({mergeParams:!0});console.log(`\tAdd controller for base route: ${o.route}`),r.use(o.route,$._populateRouter(u,i,o.controller.can))}}static _populateRouter(e,r,t={}){for(let n in t){const s=t[n];console.log(`\t\tMap route ${s.over} on (${s.on}) to ${r.constructor.name}.${n} method.`),e[s.on](s.over,r[n].bind(r))}return e}constructor(e={}){const r={controllers:new Map,descriptors:[],...e};this.controllers=r.controllers,this.descriptors=r.descriptors,this.__dirname=void 0}get controllers(){return this._controllers}set controllers(e){if(_(e))throw new TypeError("Controllers cannot be null ! Expect a map of controller.");if(E(e))throw new TypeError("Controllers cannot be undefined ! Expect a map of controller.");if(!(e instanceof Map))throw new TypeError(`Controllers cannot be an instance of ${e.constructor.name} ! Expect a map of controller.`);this._controllers=e}get descriptors(){return this._descriptors}set descriptors(e){if(_(e))throw new TypeError("Descriptors cannot be null ! Expect an array of POJO.");if(E(e))throw new TypeError("Descriptors cannot be undefined ! Expect an array of POJO.");this._descriptors=e}addController(e){return this._controllers.set(e.name,e),this}addDescriptor(e){return this._descriptors.push(e),this}beforeRegisterRoutes(){}registerTo(e,r,t){this.beforeRegisterRoutes(e),$._registerRoutesTo(e,r,t,this._controllers,this._descriptors)}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */class A extends class{constructor(e={}){const r={driver:null,application:null,router:null,plugins:[],...e};this.driver=r.driver,this.application=r.application,this.router=r.router,this.plugins=r.plugins,this.init(),this._registerPlugins()}get plugins(){return this._plugins}set plugins(e){if(_(e))throw new TypeError("Plugins cannot be null ! Expect an array of TDatabasePlugin.");if(E(e))throw new TypeError("Plugins cannot be undefined ! Expect an array of TDatabasePlugin.");this._plugins=e}get router(){return this._router}set router(e){if(_(e))throw new TypeError("Router cannot be null ! Expect a Express Router.");if(E(e))throw new TypeError("Router cannot be undefined ! Expect a Express Router.");this._router=e}get application(){return this._application}set application(e){if(_(e))throw new TypeError("Application cannot be null ! Expect a Express Application.");if(E(e))throw new TypeError("Application cannot be undefined ! Expect a Express Application.");this._application=e}get driver(){return this._driver}set driver(e){if(_(e))throw new TypeError("Driver cannot be null ! Expect a database driver.");if(E(e))throw new TypeError("Driver cannot be undefined ! Expect a database driver.");this._driver=e}setPlugins(e){return this.plugins=e,this}setRouter(e){return this.router=e,this}setApplication(e){return this.application=e,this}setDriver(e){return this.driver=e,this}init(){}_registerPlugins(){for(let[e,r]of Object.entries(this._plugins))this._registerPackagePlugin(e,r)?console.log(`Use ${e} plugin from node_modules`):this._registerLocalPlugin(e,r)?console.log(`Use ${e} plugin from local folder`):console.error(`Unable to register the plugin ${e} the package or local folder doesn't seem to exist ! Skip it.`)}_registerPackagePlugin(e){let r=!1;try{const t=require(e);t instanceof $?(t.__dirname=b.dirname(require.resolve(e)),t.registerTo(this._driver,this._application,this._router),r=!0):console.error(`The plugin ${e} doesn't seem to be an instance of an extended class from TAbstractDatabasePlugin ! Skip it.`)}catch(e){e.code&&"MODULE_NOT_FOUND"===e.code||console.error(e)}return r}_registerLocalPlugin(e){let r=!1;try{const t=b.join(__dirname,"../../../","databases/plugins/",e,`${e}.js`),n=require(t);n instanceof $?(n.__dirname=b.dirname(require.resolve(t)),n.registerTo(this._driver,this._application,this._router),r=!0):console.error(`The plugin ${e} doesn't seem to be an instance of an extended class from TAbstractDatabasePlugin ! Skip it.`)}catch(e){console.error(e)}return r}connect(){}close(){}on(){}}
/**
 * @author [Ahmed DCHAR]{@link https://github.com/dragoneel}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @file Todo
 *
 * @example Todo
 *
 */{constructor(n={}){const s={server:"localhost",authentication:{type:"default",options:{userName:"user",password:"password",domain:""}},options:{abortTransactionOnError:!1,appName:void 0,camelCaseColumns:!1,cancelTimeout:5e3,columnNameReplacer:void 0,connectionRetryInterval:500,connectTimeout:15e3,cryptoCredentialsDetails:{},database:void 0,datefirst:7,dateFormat:"mdy",debug:{data:!1,packet:!1,payload:!1,token:!1},enableAnsiNull:!0,enableAnsiNullDefault:!0,enableAnsiPadding:!0,enableAnsiWarnings:!0,enableArithAbort:!1,enableConcatNullYieldsNull:!0,enableCursorCloseOnCommit:null,enableImplicitTransactions:!1,enableNumericRoundabort:!1,enableQuotedIdentifier:!0,encrypt:!1,fallbackToDefaultDb:!1,instanceName:void 0,language:"us_english",localAddress:void 0,maxRetriesOnTransientErrors:3,multiSubnetFailover:!1,packetSize:4096,port:1433,readOnlyIntent:!1,requestTimeout:15e3,rowCollectionOnDone:!1,rowCollectionOnRequestCompletion:!1,tdsVersion:"7_4",textsize:2147483647,trustServerCertificate:!0,useColumnNames:!1,useUTC:!0},...n};s.driver={SqlServerDriver:e,Connection:new r(s),Request:t},super(s)}close(e){this.driver.Connection.close(),e()}connect(){this.driver.Connection.on("connect",e=>{if(e)return void console.error(e);const r=this.driver.Connection.config,t=r.server,n=r.options.port,s=r.options.database;console.log(`SQLServer at ms-sql-s://${t}:${n}/${s} is connected !`)})}init(){super.init()}on(){}}
/**
 * @author [Tristan Valcke]{@link https://github.com/Itee}
 * @license [BSD-3-Clause]{@link https://opensource.org/licenses/BSD-3-Clause}
 *
 * @class TSQLServerController
 * @classdesc The TSQLServerController is the base class to perform CRUD operations on the database
 */class x extends T{constructor(e={}){const r={driver:null,tableName:"",columns:[],...e};super(r),this.tableName=r.tableName,this.columns=r.columns}get tableName(){return this._tableName}set tableName(e){const r="Expect an instance of String.";if(_(e))throw new TypeError(`Table name cannot be null ! ${r}`);if(E(e))throw new TypeError(`Table name cannot be undefined ! ${r}`);if(d(e))throw new TypeError(`Table name cannot be an instance of ${e.constructor.name} ! ${r}`);this._tableName=e}get columns(){return this._columns}set columns(e){const r="Expect an array of strings.";if(_(e))throw new TypeError(`Columns cannot be null ! ${r}`);if(E(e))throw new TypeError(`Columns cannot be undefined ! ${r}`);if(g(e))throw new TypeError(`Columns cannot be an instance of ${e.constructor.name} ! ${r}`);this._columns=e}setTableName(e){return this.tableName=e,this}setColumns(e){return this.columns=e,this}_createMany(e,r){super._createMany(e,r);const t=this.columns,n=t.toString();let s=null,a="",i=null;for(let r=0,n=e.length;r<n;r++){s=e[r],a+="(";for(let e in s)t.includes(e)&&(i=s[e],o(i)?a+=`'${i}', `:a+=`${i}, `);a=a.slice(0,-2),a+="), "}a=a.slice(0,-2);const u=`INSERT INTO ${this._tableName} (${n}) VALUES ${a}`,l=new this._driver.Request(u,this.return(r));this._driver.Connection.execSql(l)}_createOne(e,r){super._createOne(e,r);const t=this.columns;let n="",s=null,a="",i=null;for(let r=0,u=t.length;r<u;r++)s=t[r],i=e[s],i&&(n+=`${s}, `,o(i)?a+=`'${i}', `:a+=`${i}, `);n=n.slice(0,-2),a=a.slice(0,-2);const u=`INSERT INTO ${this._tableName} (${n}) VALUES (${a})`,l=new this._driver.Request(u,this.return(r));this._driver.Connection.execSql(l)}_deleteAll(e){super._deleteAll(e);const r=`TRUNCATE TABLE ${this._tableName}`,t=new this._driver.Request(r,this.return(e));this._driver.Connection.execSql(t)}_deleteMany(e,r){super._deleteMany(e,r);const t=`DELETE FROM ${this._tableName} WHERE id IN (${e})`,n=new this._driver.Request(t,this.return(r));this._driver.Connection.execSql(n)}_deleteOne(e,r){super._deleteOne(e,r);const t=`DELETE FROM ${this._tableName} WHERE id=${e}`,n=new this._driver.Request(t,this.return(r));this._driver.Connection.execSql(n)}_deleteWhere(e,r){super._deleteWhere(e,r),T.returnError("Unimplemented methods (DELETE WHERE)",r)}_readAll(e,r){super._readAll(e,r);const t=`SELECT * FROM ${this.tableName}`,n=new this._driver.Request(t,(e,t,n)=>{console.log(`Get ${t} elements.`),e?T.returnError(e,r):0===n.length?T.returnNotFound(r):T.returnData(n,r)});n.on("row",e=>{let r={};e.forEach(e=>{r[e.metadata.colName]=e.value})}),this._driver.Connection.execSql(n)}_readMany(e,r,t){super._readMany(e,r,t);const n=e.toString(),s=`SELECT * FROM ${this.tableName} WHERE id IN (${n})`,a=new this._driver.Request(s,(e,r,n)=>{console.log(`Get ${r} elements !`),e?T.returnError(e,t):0===n.length?T.returnNotFound(t):T.returnData(n,t)});a.on("row",e=>{let r={};e.forEach(e=>{r[e.metadata.colName]=e.value})}),this._driver.Connection.execSql(a)}_readOne(e,r,t){super._readOne(e,r,t);const n=`SELECT * FROM ${this.tableName} WHERE id=${e}`,s=new this._driver.Request(n,(e,r,n)=>{console.log(`Get ${r} elements !`),e?T.returnError(e,t):0===n.length?T.returnNotFound(t):T.returnData(n,t)});s.on("row",e=>{let r={};e.forEach(e=>{r[e.metadata.colName]=e.value})}),this._driver.Connection.execSql(s)}_readWhere(e,r,t){super._readWhere(e,r,t),T.returnError("Unimplemented methods (READ WHERE)",t)}_updateAll(e,r){super._updateAll(e,r);let t="";for(let r in e){const n=e[r];o(n)?t+=`${r} = '${n}', `:t+=`${r} = ${n}, `}t=t.slice(0,-2);const n=`UPDATE ${this._tableName} SET ${t}`,s=new this._driver.Request(n,this.return(r));this._driver.Connection.execSql(s)}_updateMany(e,r,t){super._updateMany(e,r,t);let n="",s=null;for(let e in r)s=r[e],o(s)?n+=`${e} = '${s}', `:n+=`${e} = ${s}, `;n=n.slice(0,-2);const a=`UPDATE ${this._tableName} SET ${n} WHERE id IN (${e})`,i=new this._driver.Request(a,this.return(t));this._driver.Connection.execSql(i)}_updateOne(e,r,t){super._updateOne(e,r,t);let n="",s=null;for(let e in r)s=r[e],o(s)?n+=`${e} = '${s}', `:n+=`${e} = ${s}, `;n=n.slice(0,-2);const a=`UPDATE ${this._tableName} SET ${n} WHERE id=${e}`,i=new this._driver.Request(a,this.return(t));this._driver.Connection.execSql(i)}_updateWhere(e,r,t){super._updateWhere(e,r,t),T.returnError("Unimplemented methods (UPDATE WHERE)",t)}}export{x as TSQLServerController,A as TSQLServerDatabase};
